<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="$(SolutionDir)/TypeScriptLanguageServiceTranspiler/bin/Debug/TypeScriptLanguageServiceTranspiler.dll" #>

<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="TypeScriptLanguageServiceTranspiler" #>
	<# 
	                Transpiler transpiler = new Transpiler();
	                transpiler.addRequiredScriptsToHost();
	                transpiler.initTypescriptLanguageService();

	                List<KeyValuePair<string,List<string>>> serviceEnums = transpiler.getServiceEnums();
	                List<KeyValuePair<string,List<string>>> compilerEnums = transpiler.getCompilerEnums();
	                List<List<KeyValuePair<string,List<string>>>> enumList = 
	                new List<List<KeyValuePair<string,List<string>>>>();
	                enumList.Add(compilerEnums);
	                enumList.Add(serviceEnums);

	                List<List<KeyValuePair<string,List<KeyValuePair<string,string>>>>> interfaceList = 
	                new List<List<KeyValuePair<string,List<KeyValuePair<string,string>>>>> ();

	                List<KeyValuePair<string,List<KeyValuePair<string,string>>>> serviceInterfaces = transpiler.getServiceInterfaces();
	                List<KeyValuePair<string,List<KeyValuePair<string,string>>>> compilerInterfaces = transpiler.getCompilerInterfaces();
	                var itemToRemove = compilerInterfaces.Single(r => r.Key == "SourceFile");
			compilerInterfaces.Remove(itemToRemove);

	                interfaceList.Add(compilerInterfaces);
	                interfaceList.Add(serviceInterfaces);
	            
	#>
//interfaces
using System;
using System.Collections.Generic;

namespace TypeScriptLanguageService { 
	<# 
	foreach ( var enums in enumList) 
	   {
		foreach ( var tsEnum in enums) 
		{

	#>

			[Flags]
			public enum <#= tsEnum.Key #> {
	<#
				foreach ( var member in tsEnum.Value) 
				{
				var m = member.Replace("$","dollar");
				m = Regex.Replace(m, @"\boperator\b", "tsOperator");
				m = Regex.Replace(m, @"\bType\b", "tsType");
	#>				<#= m #>,	
	<#			}
	#>
			}
	<#
		}
	   }
	#>


	<# 
	foreach ( var interfaces in interfaceList) 
	{
		foreach (var tsInterface in interfaces)
		{
		    if (tsInterface.Value.Count > 0)
		    {
	#>  
	    public class <#= tsInterface.Key #> {  
		    <#
		        foreach (var interfaceMember in tsInterface.Value)
		        {
		        	var type = interfaceMember.Key.Replace("boolean","bool")
		        				.Replace("number","int")
		        				.Replace("|","")
		        				.Replace("any","object")
		        				.Replace("Map<Symbol>","object")
		        				.Replace("Map<int>","object")
		        				.Replace("Map<string>","object")
		        				.Replace("Map<bool>","object")
		        				.Replace("Map<bool>","object")
		        				.Replace("Map<TypeReference>","object")
		        				.Replace("stringobject","object")
		        				.Replace("WriteFileCallback","object");



				type = Regex.Replace(type, @"\bEntityName\b", "object");
				type = Regex.Replace(type, @"\bDeclarationName\b", "object");
				type = Regex.Replace(type, @"\bIdentifierBindingPattern\b", "object");
				type = Regex.Replace(type, @"\bBlockExpression\b", "object");
				type = Regex.Replace(type, @"\bLiteralExpressionTemplateExpression\b", "object");
				type = Regex.Replace(type, @"\bVariableDeclarationListExpression\b", "object");
				type = Regex.Replace(type, @"\bCaseOrDefaultClause\b", "object");
				type = Regex.Replace(type, @"\bIdentifierLiteralExpression\b", "object");
				type = Regex.Replace(type, @"\bModuleBlockModuleDeclaration\b", "object");
				type = Regex.Replace(type, @"\bEntityNameExternalModuleReference\b", "object");
				type = Regex.Replace(type, @"\bNamespaceImportNamedImports\b", "object");
				type = Regex.Replace(type, @"\boperator\b", "object");
				type = Regex.Replace(type, @"\bNamedExports\b", "object");
				type = Regex.Replace(type, @"\bObjectType\b", "object");
				type = Regex.Replace(type, @"\bstringDiagnosticMessageChain\b", "object");
				type = Regex.Replace(type, @"\bTypeChecker\b", "object");




		        	
		        	
				var name = interfaceMember.Value.Replace("?","");
		          	name = Regex.Replace(name, @"\bout\b", "tsOut");
				name = Regex.Replace(name, @"\boperator\b", "tsOperator");

		    #>
		         public <#= type #> <#= name #>  { get; set; }
		    <#
		        }
		    #>
	    } 
	<#
		   }
		}
	}
	#> 

    public class SymbolTable {
	public string[] Symbol { get; set; }
    }

    public interface IScriptSnapshot
    {
        string getText(int start, int end);
        int getLength();
        int[] getLineStartPositions();
        TextChangeRange getChangeRange(IScriptSnapshot oldSnapshot);
    }

    public class TypeMapper {
       public object Type { get; set; }
    }

        // text change information 
    public class TextChange {
		public int pos { get; set; }
		public int deleteLen { get; set; }
		public string insertedText { get; set; }
        }

    public interface CancellationToken {
              bool isCancellationRequested();
    }
   public interface ILanguageServiceHost {
        CompilerOptions getCompilationSettings();
        string getNewLine();
        string[] getScriptFileNames();
        string getScriptVersion(string fileName);
        IScriptSnapshot getScriptSnapshot(string fileName);
        string getLocalizedDiagnosticMessages();
        CancellationToken getCancellationToken();
        string getCurrentDirectory();
        string getDefaultLibFileName(CompilerOptions options);
        void log   (string s);
        void trace (string s);
        void error (string s);
    }

    public class Program
    {

    }
}

